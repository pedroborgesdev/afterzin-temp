package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"afterzin/api/internal/auth"
	"afterzin/api/internal/graphql/model"
	"afterzin/api/internal/middleware"
	"afterzin/api/internal/qrcode"
	"afterzin/api/internal/repository"
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	existing, _ := repository.UserByEmail(r.DB, input.Email)
	if existing != nil {
		return nil, errors.New("email já cadastrado")
	}
	hash, err := auth.HashPassword(input.Password)
	if err != nil {
		return nil, err
	}
	id, err := repository.CreateUser(r.DB, input.Name, input.Email, hash, input.Cpf, input.BirthDate)
	if err != nil {
		return nil, err
	}
	user, err := repository.UserByID(r.DB, id)
	var userModel *model.User
	if user != nil {
		userModel = userRowToModel(user)
	} else {
		// Schema requires non-null user; build from input if fetch failed (e.g. SQLite datetime)
		userModel = &model.User{
			ID:        id,
			Name:      input.Name,
			Email:     input.Email,
			Cpf:       input.Cpf,
			BirthDate: input.BirthDate,
			PhotoURL:  nil,
			Role:      model.UserRoleUser,
			CreatedAt: time.Now().UTC().Format("2006-01-02T15:04:05Z07:00"),
		}
	}
	token, _ := auth.NewToken(id, "USER", r.Config.JWTSecret, 24*time.Hour)
	return &model.AuthPayload{Token: token, User: userModel}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, err := repository.UserByEmail(r.DB, input.Email)
	if err != nil || user == nil {
		return nil, errors.New("credenciais inválidas")
	}
	if !auth.CheckPassword(user.PasswordHash, input.Password) {
		return nil, errors.New("credenciais inválidas")
	}
	token, _ := auth.NewToken(user.ID, user.Role, r.Config.JWTSecret, 24*time.Hour)
	return &model.AuthPayload{Token: token, User: userRowToModel(user)}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	prodID, _ := repository.ProducerIDByUser(r.DB, userID)
	if prodID == "" {
		prodID, _ = repository.CreateProducer(r.DB, userID)
		if prodID == "" {
			return nil, errors.New("erro ao criar perfil de produtor")
		}
	}
	id, err := repository.CreateEvent(r.DB, prodID, input.Title, input.Description, input.Category, input.CoverImage, input.Location, input.Address)
	if err != nil {
		return nil, err
	}
	row, _ := repository.EventByID(r.DB, id)
	return eventRowToModel(row, r.DB)
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id string, input model.UpdateEventInput) (*model.Event, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	row, err := repository.EventByID(r.DB, id)
	if err != nil || row == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, row.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	if err := repository.UpdateEvent(r.DB, id, input.Title, input.Description, input.Category, input.CoverImage, input.Location, input.Address, nil); err != nil {
		return nil, err
	}
	row, _ = repository.EventByID(r.DB, id)
	return eventRowToModel(row, r.DB)
}

// PublishEvent is the resolver for the publishEvent field.
func (r *mutationResolver) PublishEvent(ctx context.Context, id string) (*model.Event, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	row, _ := repository.EventByID(r.DB, id)
	if row == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, row.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	if err := repository.UpdateEventStatus(r.DB, id, "PUBLISHED"); err != nil {
		return nil, err
	}
	row, _ = repository.EventByID(r.DB, id)
	return eventRowToModel(row, r.DB)
}

// UpdateEventStatus is the resolver for the updateEventStatus field.
func (r *mutationResolver) UpdateEventStatus(ctx context.Context, id string, status model.EventStatus) (*model.Event, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	row, _ := repository.EventByID(r.DB, id)
	if row == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, row.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	if err := repository.UpdateEventStatus(r.DB, id, string(status)); err != nil {
		return nil, err
	}
	row, _ = repository.EventByID(r.DB, id)
	return eventRowToModel(row, r.DB)
}

// CreateEventDate is the resolver for the createEventDate field.
func (r *mutationResolver) CreateEventDate(ctx context.Context, eventID string, input model.EventDateInput) (*model.EventDate, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	ev, _ := repository.EventByID(r.DB, eventID)
	if ev == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, ev.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	id, err := repository.CreateEventDate(r.DB, eventID, input.Date, input.StartTime, input.EndTime)
	if err != nil {
		return nil, err
	}
	return eventDateToModel(r.DB, id)
}

// CreateLot is the resolver for the createLot field.
func (r *mutationResolver) CreateLot(ctx context.Context, dateID string, input model.LotInput) (*model.Lot, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	ed, _ := repository.EventDateByID(r.DB, dateID)
	if ed == nil {
		return nil, errors.New("data não encontrada")
	}
	ev, _ := repository.EventByID(r.DB, ed.EventID)
	if ev == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, ev.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	id, err := repository.CreateLot(r.DB, dateID, input.Name, input.StartsAt, input.EndsAt, input.TotalQuantity)
	if err != nil {
		return nil, err
	}
	return lotToModel(r.DB, id)
}

// CreateTicketType is the resolver for the createTicketType field.
func (r *mutationResolver) CreateTicketType(ctx context.Context, lotID string, input model.TicketTypeInput) (*model.TicketType, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	lot, _ := repository.LotByID(r.DB, lotID)
	if lot == nil {
		return nil, errors.New("lote não encontrado")
	}
	ed, _ := repository.EventDateByID(r.DB, lot.EventDateID)
	if ed == nil {
		return nil, errors.New("data não encontrada")
	}
	ev, _ := repository.EventByID(r.DB, ed.EventID)
	if ev == nil {
		return nil, errors.New("evento não encontrado")
	}
	prod, _ := repository.ProducerByID(r.DB, ev.ProducerID)
	if prod == nil || prod.UserID != userID {
		return nil, errors.New("sem permissão")
	}
	id, err := repository.CreateTicketType(r.DB, lotID, input.Name, input.Description, input.Price, string(input.Audience), input.MaxQuantity)
	if err != nil {
		return nil, err
	}
	tt, _ := repository.TicketTypeByID(r.DB, id)
	if tt == nil {
		return nil, err
	}
	var desc *string
	if tt.Description.Valid {
		desc = &tt.Description.String
	}
	return &model.TicketType{
		ID:           tt.ID,
		Name:         tt.Name,
		Description:  desc,
		Price:        tt.Price,
		Audience:     model.AudienceType(tt.Audience),
		MaxQuantity:  tt.MaxQuantity,
		SoldQuantity: tt.SoldQuantity,
	}, nil
}

// CheckoutPreview is the resolver for the checkoutPreview field.
func (r *mutationResolver) CheckoutPreview(ctx context.Context, input model.CheckoutInput) (*model.CheckoutPreviewResult, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	if len(input.Items) == 0 {
		return nil, errors.New("nenhum item")
	}
	var total float64
	var items []*model.CheckoutPreviewItem
	for _, it := range input.Items {
		tt, _ := repository.TicketTypeByID(r.DB, it.TicketTypeID)
		if tt == nil {
			return nil, errors.New("tipo de ingresso não encontrado")
		}
		if it.Quantity <= 0 || tt.SoldQuantity+it.Quantity > tt.MaxQuantity {
			return nil, errors.New("quantidade indisponível")
		}
		ed, _ := repository.EventDateByID(r.DB, it.EventDateID)
		if ed == nil {
			return nil, errors.New("data não encontrada")
		}
		ev, _ := repository.EventByID(r.DB, ed.EventID)
		if ev == nil {
			return nil, errors.New("evento não encontrado")
		}
		sub := float64(it.Quantity) * tt.Price
		total += sub
		items = append(items, &model.CheckoutPreviewItem{
			EventTitle:     ev.Title,
			EventDate:      ed.Date,
			TicketTypeName: tt.Name,
			Quantity:       it.Quantity,
			UnitPrice:      tt.Price,
			Subtotal:       sub,
		})
	}
	orderID, err := repository.CreateOrder(r.DB, userID, total, 30*time.Minute)
	if err != nil {
		return nil, err
	}
	for _, it := range input.Items {
		tt, _ := repository.TicketTypeByID(r.DB, it.TicketTypeID)
		if tt == nil {
			continue
		}
		_, _ = repository.CreateOrderItem(r.DB, orderID, it.EventDateID, it.TicketTypeID, it.Quantity, tt.Price)
	}
	return &model.CheckoutPreviewResult{
		CheckoutID: orderID,
		Total:      total,
		Items:      items,
	}, nil
}

// CheckoutPay is the resolver for the checkoutPay field.
func (r *mutationResolver) CheckoutPay(ctx context.Context, input model.CheckoutPayInput) (*model.CheckoutPayResult, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	orderUserID, status, _, err := repository.OrderByID(r.DB, input.CheckoutID)
	if err != nil || orderUserID == "" {
		return nil, errors.New("pedido não encontrado")
	}
	if orderUserID != userID {
		return nil, errors.New("pedido não pertence ao usuário")
	}
	if status == "PAID" {
		msg := "Pedido já pago."
		return &model.CheckoutPayResult{Success: true, Message: &msg}, nil
	}
	items, err := repository.OrderItemsByOrderID(r.DB, input.CheckoutID)
	if err != nil {
		return nil, err
	}
	var ticketIDs []string
	for _, it := range items {
		evDate, _ := repository.EventDateByID(r.DB, it.EventDateID)
		if evDate == nil {
			continue
		}
		ev, _ := repository.EventByID(r.DB, evDate.EventID)
		if ev == nil {
			continue
		}
		for i := 0; i < it.Quantity; i++ {
			id := uuid.New().String()
			code := repository.GenerateTicketCode()
			qrPayload := qrcode.GenerateSignedPayload(id, []byte(r.Config.JWTSecret))
			err := repository.CreateTicketWithID(r.DB, id, code, qrPayload, input.CheckoutID, it.ID, userID, ev.ID, it.EventDateID, it.TicketTypeID)
			if err != nil {
				continue
			}
			ticketIDs = append(ticketIDs, id)
			repository.IncrementTicketTypeSold(r.DB, it.TicketTypeID, 1)
			lotID, _ := repository.LotIDByTicketTypeID(r.DB, it.TicketTypeID)
			repository.DecrementLotAvailable(r.DB, lotID, 1)
		}
	}
	if err := repository.ConfirmOrder(r.DB, input.CheckoutID); err != nil {
		return nil, err
	}
	msg := "Após a confirmação do pagamento, o ingresso ficará disponível na sua Mochila de Tickets."
	return &model.CheckoutPayResult{
		Success:   true,
		TicketIds: ticketIDs,
		Message:   &msg,
	}, nil
}

// UpdateProfilePhoto is the resolver for the updateProfilePhoto field.
func (r *mutationResolver) UpdateProfilePhoto(ctx context.Context, photoBase64 string) (*model.User, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	payload := photoBase64
	if len(payload) > 7 && (payload[:7] == "data:img" || payload[:10] == "data:image/") {
		idx := 0
		for i, c := range payload {
			if c == ',' {
				idx = i + 1
				break
			}
		}
		if idx > 0 {
			payload = payload[idx:]
		}
	}
	if len(payload) > 300*1024 { // ~300 KB in base64 is ~400k chars; allow up to 400k for safety
		return nil, errors.New("imagem muito grande; máximo 300 KB")
	}
	// Accept only base64 that decodes to image (we store as data URI for display)
	normalized := "data:image/jpeg;base64," + payload
	if len(normalized) > 500*1024 {
		return nil, errors.New("imagem muito grande; máximo 300 KB")
	}
	if err := repository.UpdateUserPhotoURL(r.DB, userID, normalized); err != nil {
		return nil, err
	}
	user, _ := repository.UserByID(r.DB, userID)
	return userRowToModel(user), nil
}

// ValidateTicket is the resolver for the validateTicket field.
// Uses signed QR payloads; validates then marks ticket as used in a single atomic update to prevent double validation.
func (r *mutationResolver) ValidateTicket(ctx context.Context, eventID string, qrCode string) (*model.ValidateTicketResult, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("UNAUTHORIZED"), Message: strPtr("não autenticado")}, nil
	}
	prodID, _ := repository.ProducerIDByUser(r.DB, userID)
	if prodID == "" {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("FORBIDDEN"), Message: strPtr("apenas produtores podem validar ingressos")}, nil
	}
	eventProducerID, err := repository.EventProducerID(r.DB, eventID)
	if err != nil || eventProducerID == "" {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("NOT_FOUND"), Message: strPtr("evento não encontrado")}, nil
	}
	if eventProducerID != prodID {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("WRONG_EVENT"), Message: strPtr("ingresso não pertence a este evento ou você não é o produtor")}, nil
	}
	// QR lookup: try direct DB match first, then V2 signed payload, then V1 signed payload.
	t, err := repository.TicketByQRCode(r.DB, qrCode)
	if err != nil || t == nil {
		// Try V2 QR payload: ticketID:paymentIntentID:eventID.signature
		if ticketID, _, _, sigOK := qrcode.VerifySignedPayloadV2(qrCode, []byte(r.Config.JWTSecret)); sigOK {
			t, err = repository.TicketByID(r.DB, ticketID)
		}
		// Try V1 QR payload: ticketID.signature
		if err != nil || t == nil {
			if ticketID, sigOK := qrcode.VerifySignedPayload(qrCode, []byte(r.Config.JWTSecret)); sigOK {
				t, err = repository.TicketByID(r.DB, ticketID)
			}
		}
	}
	if err != nil || t == nil {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("NOT_FOUND"), Message: strPtr("ingresso não encontrado")}, nil
	}
	if t.EventID != eventID {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("WRONG_EVENT"), Message: strPtr("ingresso não pertence a este evento")}, nil
	}
	// Atomic update: only one validation can succeed (prevents concurrent double use)
	updated, err := repository.MarkTicketUsedIfNotUsed(r.DB, t.ID)
	if err != nil {
		return &model.ValidateTicketResult{Success: false, Message: strPtr("erro ao validar")}, nil
	}
	if !updated {
		return &model.ValidateTicketResult{Success: false, ErrorCode: strPtr("ALREADY_USED"), Message: strPtr("ingresso já utilizado")}, nil
	}
	_ = repository.InsertTicketValidation(r.DB, t.ID, eventID, prodID)
	t.Used = 1
	ticket, _ := ticketRowToModel(r.DB, t)
	return &model.ValidateTicketResult{Success: true, Ticket: ticket}, nil
}

func strPtr(s string) *string { return &s }

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, filter *model.EventFilter) ([]*model.Event, error) {
	var cat, date, city *string
	if filter != nil {
		cat, date, city = filter.Category, filter.Date, filter.City
	}
	ids, err := repository.ListPublishedEvents(r.DB, cat, date, city)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Event, 0, len(ids))
	for _, id := range ids {
		row, _ := repository.EventByID(r.DB, id)
		if row == nil {
			continue
		}
		ev, err := eventRowToModel(row, r.DB)
		if err != nil {
			continue
		}
		out = append(out, ev)
	}
	return out, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	row, err := repository.EventByID(r.DB, id)
	if err != nil || row == nil {
		return nil, nil
	}
	return eventRowToModel(row, r.DB)
}

// ProducerEvents is the resolver for the producerEvents field.
func (r *queryResolver) ProducerEvents(ctx context.Context) ([]*model.Event, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	prodID, _ := repository.ProducerIDByUser(r.DB, userID)
	if prodID == "" {
		return []*model.Event{}, nil
	}
	ids, err := repository.ListEventsByProducerID(r.DB, prodID)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Event, 0, len(ids))
	for _, id := range ids {
		row, _ := repository.EventByID(r.DB, id)
		if row == nil {
			continue
		}
		ev, err := eventRowToModel(row, r.DB)
		if err != nil {
			continue
		}
		out = append(out, ev)
	}
	return out, nil
}

// ProducerPublicProfile is the resolver for the producerPublicProfile field.
func (r *queryResolver) ProducerPublicProfile(ctx context.Context, producerID string) (*model.ProducerPublicProfile, error) {
	prod, err := repository.ProducerByID(r.DB, producerID)
	if err != nil || prod == nil {
		return nil, nil
	}
	user, _ := repository.UserByID(r.DB, prod.UserID)
	if user == nil {
		return nil, nil
	}
	var company *string
	if prod.CompanyName.Valid {
		company = &prod.CompanyName.String
	}
	producer := &model.Producer{
		ID:          prod.ID,
		User:        userRowToModel(user),
		CompanyName: company,
		Approved:    prod.Approved == 1,
	}
	eventIDs, err := repository.ListEventsByProducerIDExcludingDraft(r.DB, producerID)
	if err != nil {
		return &model.ProducerPublicProfile{Producer: producer, Events: []*model.Event{}}, nil
	}
	events := make([]*model.Event, 0, len(eventIDs))
	for _, id := range eventIDs {
		row, _ := repository.EventByID(r.DB, id)
		if row == nil {
			continue
		}
		ev, err := eventRowToModel(row, r.DB)
		if err != nil {
			continue
		}
		events = append(events, ev)
	}
	return &model.ProducerPublicProfile{Producer: producer, Events: events}, nil
}

// MyTickets is the resolver for the myTickets field.
func (r *queryResolver) MyTickets(ctx context.Context) ([]*model.Ticket, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	list, err := repository.TicketsByUserID(r.DB, userID)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Ticket, 0, len(list))
	for _, t := range list {
		ticket, err := ticketRowToModel(r.DB, t)
		if err != nil {
			continue
		}
		out = append(out, ticket)
	}
	return out, nil
}

// MyTicket is the resolver for the myTicket field.
func (r *queryResolver) MyTicket(ctx context.Context, id string) (*model.Ticket, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, errors.New("não autenticado")
	}
	t, err := repository.TicketByID(r.DB, id)
	if err != nil || t == nil || t.UserID != userID {
		return nil, nil
	}
	return ticketRowToModel(r.DB, t)
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, nil
	}
	user, _ := repository.UserByID(r.DB, userID)
	return userRowToModel(user), nil
}

// ProducerMe is the resolver for the producerMe field.
func (r *queryResolver) ProducerMe(ctx context.Context) (*model.Producer, error) {
	userID := middleware.UserID(ctx)
	if userID == "" {
		return nil, nil
	}
	prodID, _ := repository.ProducerIDByUser(r.DB, userID)
	if prodID == "" {
		return nil, nil
	}
	prod, _ := repository.ProducerByID(r.DB, prodID)
	if prod == nil {
		return nil, nil
	}
	user, _ := repository.UserByID(r.DB, prod.UserID)
	var company *string
	if prod.CompanyName.Valid {
		company = &prod.CompanyName.String
	}
	return &model.Producer{
		ID:          prod.ID,
		User:        userRowToModel(user),
		CompanyName: company,
		Approved:    prod.Approved == 1,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
